# What is REST ?

REST API stands for Representational State Transfer Application Programming Interface. It is a set of rules that developers follow when they create an API. REST is an architectural style for designing networked applications and is not a protocol or standard in itself. APIs that adhere to the principles of REST are known as RESTful APIs.Here are the key principles of RESTful API design:
1. Client-Server Architecture: The client and the server should be independent of each other. The client is responsible for the user interface and user-related operations, while the server is responsible for data storage, performance, and scalability.
2. Statelessness: Each request from the client to the server must contain all of the information necessary to understand and complete the request. The server does not store any state about the client session on the server side.
3. Cacheability: Resources should be cacheable to improve performance. When a client requests a resource, the response should define whether the resource is cacheable and for how long.
4. Uniform Interface: The interface between clients and servers is standardized. This simplification helps decouple the architecture, which allows each part to evolve independently. The uniform interface is facilitated by using standard HTTP methods (GET, POST, PUT, DELETE, etc.).
5. Layered System: The client should not be able to tell whether it is connected directly to the end server, or to an intermediary along the way. Intermediary servers might offer load balancing and shared caches.
6. Code on Demand (optional): Servers can extend client functionality by transferring executable code to the client. This is an optional constraint.RESTful APIs are commonly used to create interactive applications that use web services. When a client sends a request to a web service, the service performs some processing and returns a response, often in a format like JSON or XML. This approach allows for greater scalability and flexibility in integrating with other applications or services.


REST, the "representational state" is the current state of a resource provided to the client through a representation, such as JSON or XML, which the client can use to understand and manipulate the resource.


An API is considered RESTful when it adheres to the architectural principles and constraints of REST. These principles guide how the server exposes information to the client through a set of well-defined operations on named resources. Below are the key principles that make an API RESTful, along with examples:
1. Client-Server Architecture: The client application and the server application must be able to evolve independently. The client should not need to know the inner workings of the server.Example: A mobile application (client) interacts with a server via RESTful API calls to fetch user data. The client only knows the URI of the resource and the protocol (HTTP) for communication.
2. Statelessness: Each request from the client to the server must contain all the information needed to understand and complete the request. The server should not store session state, which helps to improve scalability and reliability.Example: When a client requests a list of blog posts from a blogging platform's RESTful API, it might send an HTTP GET request to https://api.bloggingplatform.com/posts. The server's response contains the list of posts without requiring any prior knowledge of past requests.
3. Cacheability: The server's responses should explicitly state whether the response is cacheable or not, which can reduce client-server interactions and improve system efficiency.Example: A RESTful API response might contain headers like Cache-Control: max-age=3600, indicating that the response can be cached by the client or intermediate proxies for an hour.
4. Uniform Interface: The interface between the client and server should be uniform and standardized, which simplifies the architecture and decouples clients from servers.
    * Resource Identification: Resources are identified using URIs.
    * Resource Manipulation through Representations: When a client holds a representation of a resource, including any metadata attached, it has enough information to modify or delete the resource.
    * Self-descriptive Messages: Each message includes enough information to describe how to process the message.
    * Hypermedia as the Engine of Application State (HATEOAS): Clients interact with the application entirely through hypermedia provided dynamically by application servers.
5. Example: In a RESTful API for an online store, products might be accessed via a URI like https://api.onlinestore.com/products/12345. The product details could be retrieved using an HTTP GET request, updated using a PUT or PATCH request, and deleted using a DELETE request.
6. Layered System: The client should not be able to tell whether it is communicating directly with the end server or an intermediary. This allows for various layers to exist, such as load balancers or shared caches, to improve system scalability and security.Example: When a client requests a resource from a RESTful API, it might be routed through a load balancer. The client is unaware of this intermediary and doesn't need to be configured differently to handle it.
7. Code on Demand (optional): Servers can temporarily extend or customize the functionality of a client by transferring executable code, such as scripts.Example: A RESTful API might provide a client with a small piece of JavaScript code to handle a specific type of data formatting on the client side. This is the only optional constraint of REST.



Certainly! The uniform interface is one of the central concepts in REST and it simplifies the architecture of the system by enabling a standard way to access and manage resources. It consists of several key constraints:
1. Resource Identification in Requests: Each resource in the system should have a unique identifier, typically a URI (Uniform Resource Identifier). This allows each resource to be accessed through a specific endpoint.Example: In a RESTful API for an online library, each book could be identified by a URI like https://api.onlinelibrary.com/books/123, where 123 is the unique identifier for a specific book.
2. Resource Manipulation through Representations: When a client holds a representation of a resource, it has enough information to modify or delete the resource on the server, provided it has permission to do so.Example: If the client wants to update the information for the book with ID 123, it might send a PUT request to https://api.onlinelibrary.com/books/123 with the new data in the request body.
3. Self-descriptive Messages: Each message (request or response) must contain all the information needed to understand the message. This typically includes information about how to process the message (via MIME types, for example), authorization, cache directives, etc.Example: A RESTful API response might include a Content-Type header like application/json, which indicates that the message body is a JSON document.
4. Hypermedia as the Engine of Application State (HATEOAS): Clients interact with the application entirely through hypermedia provided dynamically by the server. The idea is that the client doesn't need to know the structure of the API; instead, it discovers the available actions from the hypermedia (like links and forms) included in the responses.Example: A response to a request for a book might include links to related resources, such as authors, reviews, or recommendations. For instance:{  5.     "id": "123",  
6.     "title": "RESTful Example",  
7.     "author": "Jane Doe",  
8.     "links": [  
9.         {"rel": "author", "href": "https://api.onlinelibrary.com/authors/456"},  
10.         {"rel": "reviews", "href": "https://api.onlinelibrary.com/books/123/reviews"}  
11.     ]  
12. }  In this JSON representation, there are hyperlinks (HATEOAS) that tell the client where to find the author's information and the book reviews. The client can navigate the API purely through these links without prior knowledge of the API's URI structure.These constraints ensure that the RESTful API has a uniform interface, which helps to decouple the client and server implementations. Each part can evolve separately without affecting the other, as long as the uniform interface and its constraints are respected. This uniformity also makes it easier for new clients to use the API, as they can apply the same general principles to interact with any resource provided by the server.


Client — server separation
The client and the server act independently, each on its own, and the interaction between them is only in the form of requests, initiated by the client only, and responses, which the server send to the client only as a reaction to a request. The server just sits there waiting for requests from the client to come. The server doesn’t start sending away information about the state of some resources on its own